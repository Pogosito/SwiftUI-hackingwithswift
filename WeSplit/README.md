# Day 16

## Form/Text/Group/Section
 
 В SwiftUI есть убнобный инструмент для создания формы с помощью ***Form***
 (Form по своей сути напоминает tableView со статическими ячейками), в ячейках могут находится не только ***Text***, но и другие элементы, как ***Stepper***, ***Toggle*** или кастомные решения.
 
 Есть ограничения в количестве дочерних элементов у ***Form*** - не больше 10, такое ограничение можно наблюдять и для других элементов, которые могут иметь subview
 
 Чтобы обойти это ограничние можно группировать дочерние элементы в ***Group*** или ***Section***
 Отличие между ними лишь в том, что ***Section*** разделяет элементы не только в коде но и у пользователся на экране, а ***Group*** группирует элементы только в коде
 
 ## NavigationView

 В курсе ***NavigationView*** был представлен, как решение ситуации, когда элементы UI перекрывались системными вещами такими как: показаль зарядки, время и т.д. Также если обернуть view в navigationView, то появляется возможность задать title
 Также NavigationView открывает возможность добавлять на naviagtionBar  разные элементы
 
 Стоит отметить, что  модификаторы:  ***navigationBarTitle*** , ***.navigationTitle*** и др. (модификатор - это та же функция) нужно прописывать для объекта, который обернут в ***NavigationView***, а не для самого ***NavigationView***.  (Почему? Ответ будет в 17 день)
 
 ## @State
 
 Надо понимать, что в SwiftUI заложена другая природа программирования: "Вид является функцией его состояния"
 Что это может значить. Когда программируешь на UIKit, можно создать var label: UILabel = ..., который будет отображать текст var str: string = ..., информация str - это состояние label, но оно живет отдельно от самого label (т.е при изменении str, отображаемая информация не поменяется), а в SwiftUI сделали так, что сам view отвечает за свое состояние (в нашем примере label сам отслеживает изменения, которые произошли и сам в состоянии отобразить новую информацию). Чтобы добиться такого, нужно отметить переменную str оберткой ***@State***. 
 
 Важно помнить, что мы работаем с структурами, которые по своей природе неизменяемы, поэтому, когда мы отмечаем свойство, как состояние, важно понимать, что храним мы это свойство, где - то за пределеми нашей структуры (где узнаем далее)
 
 Также пока мне непонятно, но Apple рекомендует отмечать состояния как ***private*** 

## Two-way binding

Как упоминалось выше, чтобы отслеживать изменения свойства, которые отображаются на экране, нужно отметить это свойство как @State. Ну а что делать, если само view способено изменять отображаемое значение, например, как ***textView***.  Суть в том, что Swift различает “показать значение этого свойства здесь” и “показать значение этого свойства здесь, но записать любые изменения обратно в свойство".
Для  второго используйте ***two-way binding*** (двусторонняя привязка) (поставить знак $ перед значением, которое меняется)

## Views in Loop/Picker

SwiftUI дает отличную возможность создавать view вунтри цикла с помощью ***ForEach*** (также, что интересно для ForEach нет ограничений в количестве создаваемых view). ***ForEach*** идет в ногу с таким элементом, как ***Picker***, можно легко создавать выбор для пользователя

# Day 17

## TextField 

***TextFiled*** - это строка, в которой можно вписать текст. ***TextField*** требует при инициализации вписать переменную типа ****Binding<String>****, в которой будет храниться вписанная строка (прошу заметить тут на two - way bindings, т.е на способность самого TextField не только отображать значение переменной, но и обновлять его)

***TextField*** по умолчанию дает пользователю вводить символы с помощью привычной нам клавиатуры, но мы можем с помощью модификатора .keyboardType() дать пользователю вводить только цифры или же цифры + десятичная точка/запятая (точка или запятая смотря какая локализация установлена на устройстве)

(весь перечень стилей можно посмотреть на сайте: https://developer.apple.com/documentation/uikit/uikeyboardtype)

Стоит отметить, что показ клавиатуры с цифрами не помешает пользователю вставить скопированный текст, состоящий из любых символов, в соответствующее текстовое поле

## Picker 

***Picker*** упоминался вчера, но напомню. ***Picker*** дает возможность реализовать список возможных ответов на определенный вопрос. Но ***Picker*** в SwiftUI умен, он способен изменять свой вид в зависимости от того, как мы его используем. Если использовать только ***Picker***, то мы получим колесо с возможностью прокручивать его, тем самым мы способный выбрать нужный вариант. Но если использовать ***Picker*** внутри ***Form***, то получим строку с возможностью перейти на страницу с возможными вариантами ответа. (Тем самым делаем очень важный вывод, SwiftUI - декларативный framework, т.е мы говорим "что хотим", вместо того "как должно быть сделано"). 

***Picker*** может быть разных типов, чтобы изменить стиль пикера достаточно добавить модификатор  ***.pickerStyle()*** и передать аргумент тип пикера, который нужен  

(какие стикли пикера существуют можно ознакомиться в документации: https://developer.apple.com/documentation/swiftui/pickerstyle)

### Замечания:

+ Чтобы переход сработал в случае, когда ***Picker*** находится в ***Form***, нужно обязательно использовать  ***NavigationView*** (***NaviagtionView*** должен содержать ***Form***, который содержит ***Picker***)

+ Почему мы прикрепляем модификатор ***.navigationBarTitle*** именно к тому, что находится в ***NavigationView***, а не к самому  ***NavigationView*** ? Причина в том, что ***NavigationView*** способен отображать множество представлений во время работы, прикрепляя модификатор не к ***NaviagtionView*** мы даем системе изменять заголовки представлений автоматически.

+ У ***Section*** есть удобный инициализаторы, где можно указать ***Footer***, ***Header***.  

