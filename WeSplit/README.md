# Day 16

## Form/Text/Group/Section
 
 В SwiftUI есть убнобный инструмент для создания формы с помощью ***Form***
 (Form по своей сути напоминает tableView со статическими ячейками), в ячейках могут находится не только ***Text***, но и другие элементы, как ***Stepper***, ***Toggle*** или кастомные решения.
 
 Есть ограничения в количестве дочерних элементов у ***Form*** - не больше 10, такое ограничение можно наблюдять и для других элементов, которые могут иметь subview
 
 Чтобы обойти это ограничние можно группировать дочерние элементы в ***Group*** или ***Section***
 Отличие между ними лишь в том, что ***Section*** разделяет элементы не только в коде но и у пользователся на экране, а ***Group*** группирует элементы только в коде
 
 ## NavigationView

 В курсе ***NavigationView*** был представлен, как решение ситуации, когда элементы UI перекрывались системными вещами такими как: показаль зарядки, время и т.д. Также если обернуть view в navigationView, то появляется возможность задать title
 Также NavigationView открывает возможность добавлять на naviagtionBar  разные элементы
 
 Стоит отметить, что  модификаторы:  ***navigationBarTitle*** , ***.navigationTitle*** и др. (модификатор - это та же функция) нужно прописывать для объекта, который обернут в ***NavigationView***, а не для самого ***NavigationView***. 
 
 ## @State
 
 Надо понимать, что в SwiftUI заложена другая природа программирования: "Вид является функцией его состояния"
 Что это может значить. Когда программируешь на UIKit, можно создать var label: UILabel = ..., который будет отображать текст var str: string = ..., информация str - это состояние label, но оно живет отдельно от самого label (т.е при изменении str, отображаемая информация не поменяется), а в SwiftUI сделали так, что сам view отвечает за свое состояние (в нашем примере label сам отслеживает изменения, которые произошли и сам в состоянии отобразить новую информацию). Чтобы добиться такого, нужно отметить переменную str оберткой ***@State***. 
 
 Важно помнить, что мы работаем с структурами, которые по своей природе неизменяемы, поэтому, когда мы отмечаем свойство, как состояние, важно понимать, что храним мы это свойство, где - то за пределеми нашей структуры (где узнаем далее)
 
 Также пока мне непонятно, но Apple рекомендует отмечать состояния как ***private*** 

## Two-way binding

Как упоминалось выше, чтобы отслеживать изменения свойства, которые отображаются на экране, нужно отметить это свойство как @State. Ну а что делать, если само view способено изменять отображаемое значение, например, как ***textView***.  Суть в том, что Swift различает “показать значение этого свойства здесь” и “показать значение этого свойства здесь, но записать любые изменения обратно в свойство".
Для  второго используйте ***two-way binding*** (двусторонняя привязка) (поставить знак $ перед значением, которое меняется)

## Views in Loop/Picker

SwiftUI дает отличную возможность создавать view вунтри цикла с помощью ***ForEach*** (также, что интересно для ForEach нет ограничений в количестве создаваемых view). ***ForEach*** идет в ногу с таким элементом, как ***Picker***, можно легко создавать выбор для пользователя


